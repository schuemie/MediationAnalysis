# Copyright 2023 Observational Health Data Sciences and Informatics
#
# This file is part of MediationAnalysis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# library(dplyr)

#' Create model fitting settings
#'
#' @param ps            Source of the propensity score. Can be "oracle" or "fit".
#' @param mrs           Source of the mediator risk score. Can be "oracle" or "fit".
#' @param psAdjustment  Type of PS adjustment. Can be "matching", "model", 
#'                      "2D matching", "covariates", or "none".
#' @param mrsAdjustment Type of MRS adjustment. Can be "model", "2D matching", 
#'                      "covariates", or "none".
#' @param mediatorType  Type of mediator in the model. Can be "time-to-event" or
#'                      "binary".
#'
#' @return
#' A tibble with the point estimates and 95 percent confidence intervals for the
#' main effect and mediator effect. The main effect is estimated both in a model 
#' with and without the mediator. 
#' @export
createModelsettings <- function(ps = "oracle",
                                mrs = "oracle",
                                psAdjustment = "matching", 
                                mrsAdjustment = "model", 
                                mediatorType = "time-to-event") {
  settings <- list()
  for (name in names(formals("createModelsettings"))) {
    settings[[name]] <- get(name)
  }
  return(settings)
  
}

#' Fit model to estimate mediator and main effect
#'
#' @param data          A data tibble as generated by the `simulateData()`
#'                      function.
#' @param settings      A model settings object as created by the 
#'                      `createModelsettings()` function.
#'
#' @return
#' A tibble with one row and the following columns:
#' 
#' - mainLogRr: The log of the hazard ratio for the main effect (effect of 
#'   treatment on outcome) in a model including the mediator.
#' - mainLogLb: The log of the lower bound of the confidence interval for the 
#'   main effect in a model including the mediator.
#' - mainLogUb: The log of the upper bound of the confidence interval for the 
#'    main effect in a model including the mediator.
#' - mediatorLogRr: The log of the hazard ratio for the mediator effect
#' - mediatorLogLb: The log of the lower bound of the confidence interval for the 
#'   mediator effect.
#' - mediatorLogUb: The log of the upper bound of the confidence interval for the 
#'    mediator effect.
#' - mainLogRrNoM: The log of the hazard ratio for the main effect (effect of 
#'   treatment on outcome) in a model *not* including the mediator.
#' - mainLogLbNoM: The log of the lower bound of the confidence interval for the 
#'   main effect in a model *not* including the mediator.
#' - mainLogUbNoM: The log of the upper bound of the confidence interval for the 
#'    main effect in a model *not* including the mediator.
#'
#' @export
fitModel <- function(data, settings) {
  
  f <- formula(Surv(tStart, tEnd, y) ~ a)
  
  if (settings$ps == "oracle") {
    data$ps <- data$pA
  } else if (settings$ps == "fit") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    psF <- as.formula(paste("a ~ ", paste(xNames, collapse = " + ")))
    cyclopsData <- Cyclops::createCyclopsData(psF, data = data, modelType = "lr")
    fit <- Cyclops::fitCyclopsModel(cyclopsData)
    data$ps <- predict(fit)
  } else {
    stop("Unknown PS source: ", settings$ps) 
  }
  
  if (settings$mrs == "oracle") {
    data$mrs <- data$hMstar
  } else if (settings$ps == "fit") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    psF <- as.formula(paste("m ~ offset(log(tM)) + ", paste(xNames, collapse = " + ")))
    cyclopsData <- Cyclops::createCyclopsData(psF, data = data, modelType = "pr")
    fit <- Cyclops::fitCyclopsModel(cyclopsData)
    data$mrs <- predict(fit) / data$tM
  } else {
    stop("Unknown PS source: ", settings$ps) 
  }
  
  if (settings$mrsAdjustment == "model") {
    f <- update(f, ~ . + ns(mrs, 5)) 
  } else if (settings$mrsAdjustment == "covariates") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    newF <- as.formula(paste("~ . + ", paste(xNames, collapse = " + ")))
    f <- update(f, newF) 
  } else if (settings$mrsAdjustment == "2D matching") {
    if (settings$psAdjustment != "2D matching") {
      stop("If mrsAdjustment = '2D matching' then psAdjustment should also be '2D matching'")
    }
  }  else if (settings$mrsAdjustment == "none") {
    # Do nothing
  } else {
    stop("Unknown mAdjustment: ", settings$mrsAdjustment) 
  }
  
  if (settings$psAdjustment == "matching") {
    data <- data %>%
      mutate(propensityScore = ps,
             treatment = a,
             rowId = row_number()) %>%
      CohortMethod::matchOnPs(maxRatio = 100) %>%
      select(-"propensityScore", -"treatment", -"rowId")
    f <- update(f, ~ . + strata(stratumId))
  } else if (settings$psAdjustment == "model") {
    f <- update(f, ~ . + ns(ps, 5))
  } else if (settings$psAdjustment == "covariates") {
    if (settings$mrsAdjustment != "covariates") {
      stop("If mrsAdjustment = 'covariates' then psAdjustment should also be 'covariates'")
    }
  } else if (settings$psAdjustment == "2D matching") {
    matchit <- MatchIt::matchit(a ~ ps + mrs, 
                                method = "nearest", 
                                distance ="euclidean", 
                                caliper = c("ps" = 0.02, "mrs" = 0.02),
                                std.caliper = FALSE,
                                ratio = 100,
                                data = data)
    data <- MatchIt::match.data(matchit, data = data, subclass = "stratumId")
    f <- update(f, ~ . + strata(stratumId))
  } else if (settings$psAdjustment == "none") {
    # Do nothing
  } else {
    stop("Unknown psAdjustment: ", settings$psAdjustment) 
  }
  
  if (settings$mediatorType == "time-to-event") {
    # Split time before / after mediator
    data <- bind_rows(
      data %>%
        filter(!m),
      data %>%
        filter(m) %>%
        mutate(tEnd = tM,
               m = FALSE,
               y = FALSE),
      data %>%
        filter(m) %>%
        mutate(tStart = tM)
    )
  } else if (settings$mediatorType == "binary") {
    # Do nothing 
  } else {
    stop("Unknown mType: ", settings$mediatorType) 
  }
  # Cleanup: remove (near) zero-length intervals:
  data <- data %>%
    filter(tEnd - tStart > 0.0001)
  
  # With mediator:
  fit1 <- coxph(update(f, ~ . + m), data = data)
  ci1 <- confint(fit1)
  e1 <- coef(fit1)
  
  # Without mediator:
  fit2 <- coxph(f, data = data)
  ci2 <- confint(fit2)
  e2 <- coef(fit2)
  
  result <- tibble(mainLogHr = e1["aTRUE"],
                   mainLogLb = ci1["aTRUE", 1],
                   mainLogUb = ci1["aTRUE", 2],
                   mediatorLogHr = e1["mTRUE"],
                   mediatorLogLb = ci1["mTRUE", 1],
                   mediatorLogUb = ci1["mTRUE", 2],
                   mainLogHrNoM = e2["aTRUE"],
                   mainLogLbNoM = ci2["aTRUE", 1],
                   mainLogUbNoM = ci2["aTRUE", 2])
  return(result)
}
