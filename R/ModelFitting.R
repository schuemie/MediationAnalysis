# Copyright 2024 Observational Health Data Sciences and Informatics
#
# This file is part of MediationAnalysis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# library(dplyr)
# data = simulateData(createSimulationSettings())
# settings = createModelsettings()

sampling <- "strata" # strata or person
bootstrapType <- "percentile" # percentile or pivoted

#' Create model fitting settings
#'
#' @param ps            Source of the propensity score. Can be "oracle" or "fit".
#' @param mrs           Source of the mediator risk score. Can be "oracle" or "fit".
#' @param psAdjustment  Type of PS adjustment. Can be "matching", "model", 
#'                      "2D matching", "covariates", or "none".
#' @param mrsAdjustment Type of MRS adjustment. Can be "model", "2D matching", 
#'                      "covariates", or "none".
#' @param mediatorType  Type of mediator in the model. Can be "time-to-event" or
#'                      "binary".
#'
#' @return
#' A tibble with the point estimates and 95 percent confidence intervals for the
#' main effect and mediator effect. The main effect is estimated both in a model 
#' with and without the mediator. 
#' @export
createModelsettings <- function(ps = "oracle",
                                mrs = "oracle",
                                psAdjustment = "matching", 
                                mrsAdjustment = "model", 
                                mediatorType = "time-to-event") {
  settings <- list()
  for (name in names(formals("createModelsettings"))) {
    settings[[name]] <- get(name)
  }
  return(settings)
  
}

#' Fit model to estimate mediator and main effect
#'
#' @param data          A data tibble as generated by the `simulateData()`
#'                      function.
#' @param settings      A model settings object as created by the 
#'                      `createModelsettings()` function.
#'
#' @return
#' A tibble with one row and the following columns:
#' 
#' - mainLogRr: The log of the hazard ratio for the main effect (effect of 
#'   treatment on outcome) in model that does *not* account for the mediator.
#' - mainLogLb: The log of the lower bound of the 95 percent confidence interval for the 
#'   main effect.
#' - mainLogUb: The log of the upper bound of the 95 percent confidence interval for the 
#'    main effect.
#' - mediatorLogRr: The log of the hazard ratio for the mediator effect (effect of mediator on
#'   outcome).
#' - mediatorLogLb: The log of the lower bound of the 95 percent confidence interval for the 
#'   mediator effect.
#' - mediatorLogUb: The log of the upper bound of the 95 percent confidence interval for the 
#'    mediator effect.
#' - directLogRr: The log of the hazard ratio for the direct effect (effect of 
#'   treatment on outcome) in a model including the mediator.
#' - directLogLb: The log of the lower bound of the 95 percent confidence interval for the 
#'   direct effect.
#' - directLogUn: The log of the upper bound of the 95 percent confidence interval for the 
#'    direct effect.
#' - indirectLogRr: The log of the hazard ratio for the indirect effect (effect of 
#'   treatment on outcome through the mediator) computed using the difference method.
#' - indirectLogLb: The log of the lower bound of the 95 percent confidence interval for the 
#'   indirect effect.
#' - indirectLogUn: The log of the upper bound of the 95 percent confidence interval for the 
#'   indirect effect.
#' - trueMainHr: For simulations: the true main hazard ratio (copied directly from the `hrMain` 
#'   variable in the input).
#' - trueIndirectHr For simulations: the true indirect hazard ratio (copied directly from the 
#'   `hrIndirect` variable in the input).#'   
#'
#' @export
fitModel <- function(data, settings) {
  f <- formula(Surv(tStart, tEnd, y) ~ a)
  
  if (settings$ps == "oracle") {
    data$ps <- data$pA
  } else if (settings$ps == "fit") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    psF <- as.formula(paste("a ~ ", paste(xNames, collapse = " + ")))
    cyclopsData <- Cyclops::createCyclopsData(psF, data = data, modelType = "lr")
    fit <- Cyclops::fitCyclopsModel(cyclopsData)
    if (fit$return_flag != "SUCCESS") {
      data$ps <- data$a
    } else {
      data$ps <- predict(fit)
    }
  } else {
    stop("Unknown PS source: ", settings$ps) 
  }
  
  if (settings$mrs == "oracle") {
    data$mrs <- data$hMstar
  } else if (settings$ps == "fit") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    psF <- as.formula(paste("m ~ offset(log(tM)) + ", paste(xNames, collapse = " + ")))
    cyclopsData <- Cyclops::createCyclopsData(psF, data = data, modelType = "pr")
    fit <- Cyclops::fitCyclopsModel(cyclopsData)
    if (fit$return_flag != "SUCCESS") {
      data$mrs <- 0
    } else {
      data$mrs <- predict(fit) / data$tM
    }
  } else {
    stop("Unknown PS source: ", settings$ps) 
  }
  
  if (settings$mrsAdjustment == "model") {
    f <- update(f, ~ . + ns(log(mrs), 5)) 
  } else if (settings$mrsAdjustment == "covariates") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    newF <- as.formula(paste("~ . + ", paste(xNames, collapse = " + ")))
    f <- update(f, newF) 
  } else if (settings$mrsAdjustment == "2D matching") {
    if (settings$psAdjustment != "2D matching") {
      stop("If mrsAdjustment = '2D matching' then psAdjustment should also be '2D matching'")
    }
  }  else if (settings$mrsAdjustment == "none") {
    # Do nothing
  } else {
    stop("Unknown mAdjustment: ", settings$mrsAdjustment) 
  }
  
  if (settings$psAdjustment == "matching") {
    data <- data %>%
      mutate(propensityScore = .data$ps,
             treatment = .data$a,
             rowId = row_number()) %>%
      CohortMethod::matchOnPs(maxRatio = 100) %>%
      select(-"propensityScore", -"treatment", -"rowId")
    f <- update(f, ~ . + strata(stratumId))
    
    if (sampling == "strata") {
      nonInformativeStratumIds <- data %>%
        group_by(.data$stratumId) %>%
        summarise(total = sum(.data$y)) %>%
        filter(.data$total == 0) %>%
        pull(.data$stratumId)
      data <- data %>%
        filter(!.data$stratumId %in% nonInformativeStratumIds)
    }
  } else if (settings$psAdjustment == "model") {
    f <- update(f, ~ . + ns(ps, 5))
  } else if (settings$psAdjustment == "covariates") {
    if (settings$mrsAdjustment != "covariates") {
      stop("If mrsAdjustment = 'covariates' then psAdjustment should also be 'covariates'")
    }
  } else if (settings$psAdjustment == "2D matching") {
    matchit <- MatchIt::matchit(a ~ ps + mrs, 
                                method = "nearest", 
                                distance ="euclidean", 
                                caliper = c("ps" = 0.02, "mrs" = 0.02),
                                std.caliper = FALSE,
                                ratio = 100,
                                data = data)
    data <- MatchIt::match.data(matchit, data = data, subclass = "stratumId")
    f <- update(f, ~ . + strata(stratumId))
  } else if (settings$psAdjustment == "none") {
    # Do nothing
  } else {
    stop("Unknown psAdjustment: ", settings$psAdjustment) 
  }
  
  if (settings$mediatorType == "time-to-event") {
    # Split time before / after mediator
    data <- bind_rows(
      data %>%
        filter(!.data$m),
      data %>%
        filter(.data$m) %>%
        mutate(tEnd = .data$tM,
               m = FALSE,
               y = FALSE),
      data %>%
        filter(.data$m) %>%
        mutate(tStart = .data$tM)
    )
  } else if (settings$mediatorType == "binary") {
    # Do nothing 
  } else {
    stop("Unknown mType: ", settings$mediatorType) 
  }
  # Cleanup: remove (near) zero-length intervals:
  data <- data %>%
    filter(.data$tEnd - .data$tStart > 0.0001)
  
  # With mediator:
  control <- coxph.control(iter.max = 1000)
  fit1 <- tryCatch(coxph(update(f, ~ . + m), data = data, control = control), error = function(e) "Error")
  if (is.character(fit1) || fit1$iter == 1000) {
    directCi <- c(NA, NA)
    directLogHr <- NA 
    mediatorCi <- c(NA, NA)
    mediatorLogHr <- NA 
  } else {
    directCi <- confint(fit1, "aTRUE")
    directLogHr <- coef(fit1)["aTRUE"] 
    mediatorCi <- confint(fit1, "mTRUE")
    mediatorLogHr <- coef(fit1)["mTRUE"] 
  }
  
  # Without mediator:
  fit2 <- tryCatch(coxph(f, data = data, control = control), error = function(e) "Error")
  if (is.character(fit2) || fit2$iter == 1000) {
    mainCi <- c(NA, NA)
    mainLogHr <- NA 
  } else {
    mainCi <- confint(fit2, "aTRUE")
    mainLogHr <- coef(fit2)["aTRUE"] 
  }
  
  # Compute indirect effect using the difference method:
  indirectLogHr <- mainLogHr - directLogHr
  if (is.na(indirectLogHr)) {
    indirectCi <- c(NA, NA)
  } else if (indirectLogHr == 0) {
    indirectCi <- c(0, 0)
  } else {
    indirectCi <- computeIndirectEffectCi(data, f, indirectLogHr)
  }
  result <- tibble(mainLogHr = mainLogHr,
                   mainLogLb = mainCi[1],
                   mainLogUb = mainCi[2],directLogHr = directLogHr,
                   directLogLb = directCi[1],
                   directLogUb = directCi[2],
                   mediatorLogHr = mediatorLogHr,
                   mediatorLogLb = mediatorCi[1],
                   mediatorLogUb = mediatorCi[2],
                   indirectLogHr = indirectLogHr,
                   indirectLogLb = indirectCi[1],
                   indirectLogUb = indirectCi[2],
                   trueMainHr = data$hrMain[1],
                   trueIndirectHr = data$hrIndirect[1])
  return(result)
}

singleBootstrapSample <- function(dummy, x, y, stratumIds, uniqueStratumIds) {
  if (is.null(stratumIds)) {
    idx <- sample.int(nrow(x), nrow(x), replace = TRUE)
  } else {
    if (sampling == "strata") {
      sampledStratumIds <- sample(uniqueStratumIds$stratumId, 
                                  size = nrow(uniqueStratumIds), 
                                  prob = uniqueStratumIds$weight,
                                  replace = TRUE)
      idx <- inner_join(tibble(stratumId = sampledStratumIds), 
                        stratumIds, 
                        by = join_by("stratumId"), 
                        relationship = "many-to-many") %>%
        pull("idx")
      stratumIds <- stratumIds$stratumId[idx]
    } else {
      idx <- sample.int(nrow(x), nrow(x), replace = TRUE)
      stratumIds <- stratumIds[idx]
    }
  }
  x <- x[idx, ]
  y <- y[idx, ]
  control <- coxph.control()
  tryCatch({
    suppressWarnings({
      fit1 <- agreg.fit(x, y, stratumIds, control = control, method = "efron", rownames = seq_along(idx), init = rep(0,ncol(x)))
      fit2 <- agreg.fit(x[, -ncol(x), drop = FALSE], y, stratumIds, control = control, method = "efron", rownames = seq_along(idx),  init = rep(0, ncol(x)-1))
    })
    return(c(fit2$coefficients[1], fit1$coefficients[1]))
  },
  error = function(e) {
    return(c(NA, NA))
  })
}

computeIndirectEffectCi <- function(data, f, mle) {
  # Optimized for speed: call agreg.fit directly, which is order of magnitude faster than calling coxph:
  terms <- terms(f)
  if ("stratumId" %in% colnames(data)) {
    strataIdx <- grep("strata", attr(terms, "term.labels"))
    x <- cbind(model.matrix(terms[-strataIdx], data = data)[, -1], data$m)
    if (sampling == "strata") {
      uniqueStratumIds <- data %>%
        group_by(stratumId) %>%
        summarize(weight = sum(.data$tEnd - .data$tStart) / sum(data$tEnd - data$tStart))
      stratumIds <- data %>%
        select("stratumId") %>%
        mutate(idx = row_number())
    } else {
      uniqueStratumIds <- NULL
      stratumIds <- data$stratumId
    }
  } else {
    x <- cbind(model.matrix(terms, data = data)[, -1], data$m)
    uniqueStratumIds <- NULL
    stratumIds <- NULL
  }
  y <- Surv(data$tStart, data$tEnd, data$y)
  bootstrap <- sapply(seq_len(1000), singleBootstrapSample, x = x, y = y, stratumIds = stratumIds, uniqueStratumIds =uniqueStratumIds)  
  ci <- quantile(bootstrap[1, ] - bootstrap[2, ], c(0.025, 0.975), na.rm = TRUE)
  if (bootstrapType == "pivoted") {
    ci <- c(2*mle - ci[2], 2*mle - ci[1])
  }
  return(ci)
}
