# Copyright 2023 Observational Health Data Sciences and Informatics
#
# This file is part of MediationAnalysis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# library(dplyr)
# data = simulateData(createSimulationSettings())
# settings = createModelsettings()

#' Create model fitting settings
#'
#' @param ps            Source of the propensity score. Can be "oracle" or "fit".
#' @param mrs           Source of the mediator risk score. Can be "oracle" or "fit".
#' @param psAdjustment  Type of PS adjustment. Can be "matching", "model", 
#'                      "2D matching", "covariates", or "none".
#' @param mrsAdjustment Type of MRS adjustment. Can be "model", "2D matching", 
#'                      "covariates", or "none".
#' @param mediatorType  Type of mediator in the model. Can be "time-to-event" or
#'                      "binary".
#'
#' @return
#' A tibble with the point estimates and 95 percent confidence intervals for the
#' main effect and mediator effect. The main effect is estimated both in a model 
#' with and without the mediator. 
#' @export
createModelsettings <- function(ps = "oracle",
                                mrs = "oracle",
                                psAdjustment = "matching", 
                                mrsAdjustment = "model", 
                                mediatorType = "time-to-event") {
  settings <- list()
  for (name in names(formals("createModelsettings"))) {
    settings[[name]] <- get(name)
  }
  return(settings)
  
}

#' Fit model to estimate mediator and main effect
#'
#' @param data          A data tibble as generated by the `simulateData()`
#'                      function.
#' @param settings      A model settings object as created by the 
#'                      `createModelsettings()` function.
#'
#' @return
#' A tibble with one row and the following columns:
#' 
#' - mainLogRr: The log of the hazard ratio for the main effect (effect of 
#'   treatment on outcome) in a model including the mediator.
#' - mainLogLb: The log of the lower bound of the confidence interval for the 
#'   main effect in a model including the mediator.
#' - mainLogUb: The log of the upper bound of the confidence interval for the 
#'    main effect in a model including the mediator.
#' - mediatorLogRr: The log of the hazard ratio for the mediator effect
#' - mediatorLogLb: The log of the lower bound of the confidence interval for the 
#'   mediator effect.
#' - mediatorLogUb: The log of the upper bound of the confidence interval for the 
#'    mediator effect.
#' - mainLogRrNoM: The log of the hazard ratio for the main effect (effect of 
#'   treatment on outcome) in a model *not* including the mediator.
#' - mainLogLbNoM: The log of the lower bound of the confidence interval for the 
#'   main effect in a model *not* including the mediator.
#' - mainLogUbNoM: The log of the upper bound of the confidence interval for the 
#'    main effect in a model *not* including the mediator.
#'
#' @export
fitModel <- function(data, settings) {
  f <- formula(Surv(tStart, tEnd, y) ~ a)
  
  if (settings$ps == "oracle") {
    data$ps <- data$pA
  } else if (settings$ps == "fit") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    psF <- as.formula(paste("a ~ ", paste(xNames, collapse = " + ")))
    cyclopsData <- Cyclops::createCyclopsData(psF, data = data, modelType = "lr")
    fit <- Cyclops::fitCyclopsModel(cyclopsData)
    data$ps <- predict(fit)
  } else {
    stop("Unknown PS source: ", settings$ps) 
  }
  
  if (settings$mrs == "oracle") {
    data$mrs <- data$hMstar
  } else if (settings$ps == "fit") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    psF <- as.formula(paste("m ~ offset(log(tM)) + ", paste(xNames, collapse = " + ")))
    cyclopsData <- Cyclops::createCyclopsData(psF, data = data, modelType = "pr")
    fit <- Cyclops::fitCyclopsModel(cyclopsData)
    data$mrs <- predict(fit) / data$tM
  } else {
    stop("Unknown PS source: ", settings$ps) 
  }
  
  if (settings$mrsAdjustment == "model") {
    f <- update(f, ~ . + ns(mrs, 5)) 
  } else if (settings$mrsAdjustment == "covariates") {
    xNames <- colnames(data)[grepl("^x[0-9]+$", colnames(data))]
    newF <- as.formula(paste("~ . + ", paste(xNames, collapse = " + ")))
    f <- update(f, newF) 
  } else if (settings$mrsAdjustment == "2D matching") {
    if (settings$psAdjustment != "2D matching") {
      stop("If mrsAdjustment = '2D matching' then psAdjustment should also be '2D matching'")
    }
  }  else if (settings$mrsAdjustment == "none") {
    # Do nothing
  } else {
    stop("Unknown mAdjustment: ", settings$mrsAdjustment) 
  }
  
  if (settings$psAdjustment == "matching") {
    data <- data %>%
      mutate(propensityScore = .data$ps,
             treatment = .data$a,
             rowId = row_number()) %>%
      CohortMethod::matchOnPs(maxRatio = 100) %>%
      select(-"propensityScore", -"treatment", -"rowId")
    f <- update(f, ~ . + strata(stratumId))
    
    # Remove non-informative strata:
    nonInformativeStratumIds <- data %>%
      group_by(stratumId) %>%
      summarise(total = sum(y)) %>%
      filter(total == 0) %>%
      pull(stratumId)
    data <- data %>%
      filter(!stratumId %in% nonInformativeStratumIds)
  } else if (settings$psAdjustment == "model") {
    f <- update(f, ~ . + ns(ps, 5))
  } else if (settings$psAdjustment == "covariates") {
    if (settings$mrsAdjustment != "covariates") {
      stop("If mrsAdjustment = 'covariates' then psAdjustment should also be 'covariates'")
    }
  } else if (settings$psAdjustment == "2D matching") {
    matchit <- MatchIt::matchit(a ~ ps + mrs, 
                                method = "nearest", 
                                distance ="euclidean", 
                                caliper = c("ps" = 0.02, "mrs" = 0.02),
                                std.caliper = FALSE,
                                ratio = 100,
                                data = data)
    data <- MatchIt::match.data(matchit, data = data, subclass = "stratumId")
    f <- update(f, ~ . + strata(stratumId))
  } else if (settings$psAdjustment == "none") {
    # Do nothing
  } else {
    stop("Unknown psAdjustment: ", settings$psAdjustment) 
  }
  
  if (settings$mediatorType == "time-to-event") {
    # Split time before / after mediator
    data <- bind_rows(
      data %>%
        filter(!.data$m),
      data %>%
        filter(.data$m) %>%
        mutate(tEnd = .data$tM,
               m = FALSE,
               y = FALSE),
      data %>%
        filter(.data$m) %>%
        mutate(tStart = .data$tM)
    )
  } else if (settings$mediatorType == "binary") {
    # Do nothing 
  } else {
    stop("Unknown mType: ", settings$mediatorType) 
  }
  # Cleanup: remove (near) zero-length intervals:
  data <- data %>%
    filter(.data$tEnd - .data$tStart > 0.0001)
  
  # With mediator:
  fit1 <- coxph(update(f, ~ . + m), data = data)
  ci1 <- confint(fit1)
  e1 <- coef(fit1)
  se1 <- summary(fit1)$coef["aTRUE", 3]
  
  # Without mediator:
  fit2 <- coxph(f, data = data)
  ci2 <- confint(fit2)
  e2 <- coef(fit2)
  se2 <- summary(fit2)$coef["aTRUE", 3]
  
  # log difference with vs without mediator:
  logDiff <- e2["aTRUE"] - e1["aTRUE"]
  logDiffCi <- computeIndirectEffectCi(data, f)
  result <- tibble(mainLogHr = e1["aTRUE"],
                   mainLogLb = ci1["aTRUE", 1],
                   mainLogUb = ci1["aTRUE", 2],
                   mediatorLogHr = e1["mTRUE"],
                   mediatorLogLb = ci1["mTRUE", 1],
                   mediatorLogUb = ci1["mTRUE", 2],
                   mainLogHrNoM = e2["aTRUE"],
                   mainLogLbNoM = ci2["aTRUE", 1],
                   mainLogUbNoM = ci2["aTRUE", 2],
                   mainLogDiff = logDiff,
                   mainLogLbDiff = logDiffCi[1],
                   mainLogUbDiff = logDiffCi[2],
                   hrIndirect = data$hrIndirect[1])
  return(result)
}

singleBootstrapSample <- function(dummy, x, y, stratumId, rowNames) {
  idx <- sample.int(nrow(x), nrow(x), replace = TRUE)
  x <- x[idx, ]
  y <- y[idx, ]
  if (!is.null(stratumId)) {
    stratumId <- stratumId[idx]
  }
  control <- coxph.control()
  fit1 <- agreg.fit(x, y, stratumId, control = control, method = "efron", rownames = rowNames,  init = rep(0,ncol(x)))
  fit2 <- agreg.fit(x[, -ncol(x), drop = FALSE], y, stratumId, control = control, method = "efron", rownames = rowNames,  init = rep(0, ncol(x)-1))
  return(fit2$coefficients[1] - fit1$coefficients[1])
}

computeIndirectEffectCi <- function(data, f) {
  # Optimized for speed: call agreg.fit directly: 
  terms <- terms(f)
  if ("stratumId" %in% colnames(data)) {
    strataIdx <- grep("strata", attr(terms, "term.labels"))
    x <- cbind(model.matrix(terms[-strataIdx], data = data)[, -1], data$m)
    stratumId <- data$stratumId
  } else {
    x <- cbind(model.matrix(terms, data = data)[, -1], data$m)
    stratumId <- NULL
  }
  y <- Surv(data$tStart, data$tEnd, data$y)
  # Creating a character vector is slow, so do only once:
  rowNames <- as.character(seq_len(nrow(x)))
  bootstrap <- sapply(seq_len(1000), singleBootstrapSample, x = x, y = y, stratumId = stratumId, rowNames = rowNames)  
  ci <- quantile(bootstrap, c(0.025, 0.975))
  # Alternative: impose normal distribution for efficiency:
  # ci <- qnorm(c(0.025, 0.975), mean(bootstrap), sd(bootstrap))
  return(ci)
}
